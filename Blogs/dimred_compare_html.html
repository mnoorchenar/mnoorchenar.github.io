<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCA vs t-SNE vs UMAP Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 2em;
        }
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 0.95em;
        }
        .controls {
            background: #f7fafc;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group:last-child {
            margin-bottom: 0;
        }
        label {
            display: block;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        select, input[type="range"], button {
            width: 100%;
            padding: 10px;
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
        }
        input[type="range"] {
            padding: 0;
            height: 40px;
        }
        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: 600;
            color: #667eea;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        .charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .chart-title {
            text-align: center;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        canvas {
            max-height: 350px;
        }
        .info {
            background: #e6fffa;
            border-left: 4px solid #38b2ac;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #2d3748;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”¬ Dimensionality Reduction Comparison</h1>
        <p class="subtitle">Compare PCA, t-SNE, and UMAP visualizations on different datasets</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="dataset">Dataset:</label>
                <select id="dataset">
                    <option value="blobs">Gaussian Blobs (3 clusters)</option>
                    <option value="circles">Concentric Circles</option>
                    <option value="moons">Two Moons</option>
                    <option value="swiss">Swiss Roll</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="samples">Number of Samples: <span class="range-value" id="samplesValue">300</span></label>
                <input type="range" id="samples" min="100" max="500" value="300" step="50">
            </div>
            
            <div class="control-group">
                <label for="noise">Noise Level: <span class="range-value" id="noiseValue">0.1</span></label>
                <input type="range" id="noise" min="0" max="0.5" value="0.1" step="0.05">
            </div>
            
            <button onclick="generateData()">Generate & Visualize</button>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <div class="chart-title">PCA (Principal Component Analysis)</div>
                <canvas id="pcaChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">t-SNE (t-Distributed Stochastic Neighbor Embedding)</div>
                <canvas id="tsneChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">UMAP (Uniform Manifold Approximation)</div>
                <canvas id="umapChart"></canvas>
            </div>
        </div>
        
        <div class="info">
            <strong>ðŸ“Š About these methods:</strong><br>
            â€¢ <strong>PCA:</strong> Linear method that finds directions of maximum variance. Fast but may not capture non-linear structures.<br>
            â€¢ <strong>t-SNE:</strong> Non-linear method that preserves local structure. Great for visualization but can be slow.<br>
            â€¢ <strong>UMAP:</strong> Non-linear method balancing local and global structure. Fast and preserves more global relationships than t-SNE.
        </div>
    </div>

    <script>
        let charts = {};
        const colors = ['#667eea', '#f56565', '#48bb78', '#ed8936', '#9f7aea'];
        
        // Update range displays
        document.getElementById('samples').addEventListener('input', (e) => {
            document.getElementById('samplesValue').textContent = e.target.value;
        });
        document.getElementById('noise').addEventListener('input', (e) => {
            document.getElementById('noiseValue').textContent = e.target.value;
        });
        
        // Generate datasets
        function generateBlobs(n, noise) {
            const data = [];
            const labels = [];
            const centers = [[2, 2, 2], [7, 7, 7], [2, 7, 2]];
            const pointsPerCluster = Math.floor(n / 3);
            
            centers.forEach((center, idx) => {
                for (let i = 0; i < pointsPerCluster; i++) {
                    data.push([
                        center[0] + (Math.random() - 0.5) * noise * 10,
                        center[1] + (Math.random() - 0.5) * noise * 10,
                        center[2] + (Math.random() - 0.5) * noise * 10
                    ]);
                    labels.push(idx);
                }
            });
            return { data, labels };
        }
        
        function generateCircles(n, noise) {
            const data = [];
            const labels = [];
            const pointsPerCircle = Math.floor(n / 2);
            
            for (let i = 0; i < pointsPerCircle; i++) {
                const angle = Math.random() * 2 * Math.PI;
                data.push([
                    Math.cos(angle) * 2 + (Math.random() - 0.5) * noise,
                    Math.sin(angle) * 2 + (Math.random() - 0.5) * noise,
                    (Math.random() - 0.5) * noise
                ]);
                labels.push(0);
            }
            
            for (let i = 0; i < pointsPerCircle; i++) {
                const angle = Math.random() * 2 * Math.PI;
                data.push([
                    Math.cos(angle) * 5 + (Math.random() - 0.5) * noise,
                    Math.sin(angle) * 5 + (Math.random() - 0.5) * noise,
                    (Math.random() - 0.5) * noise
                ]);
                labels.push(1);
            }
            return { data, labels };
        }
        
        function generateMoons(n, noise) {
            const data = [];
            const labels = [];
            const pointsPerMoon = Math.floor(n / 2);
            
            for (let i = 0; i < pointsPerMoon; i++) {
                const angle = Math.PI * i / pointsPerMoon;
                data.push([
                    Math.cos(angle) * 3 + (Math.random() - 0.5) * noise,
                    Math.sin(angle) * 3 + (Math.random() - 0.5) * noise,
                    (Math.random() - 0.5) * noise
                ]);
                labels.push(0);
            }
            
            for (let i = 0; i < pointsPerMoon; i++) {
                const angle = Math.PI * i / pointsPerMoon;
                data.push([
                    1 - Math.cos(angle) * 3 + (Math.random() - 0.5) * noise,
                    0.5 - Math.sin(angle) * 3 + (Math.random() - 0.5) * noise,
                    (Math.random() - 0.5) * noise
                ]);
                labels.push(1);
            }
            return { data, labels };
        }
        
        function generateSwissRoll(n, noise) {
            const data = [];
            const labels = [];
            
            for (let i = 0; i < n; i++) {
                const t = 1.5 * Math.PI * (1 + 2 * i / n);
                const x = t * Math.cos(t);
                const y = 21 * i / n;
                const z = t * Math.sin(t);
                data.push([
                    x + (Math.random() - 0.5) * noise * 5,
                    y + (Math.random() - 0.5) * noise * 5,
                    z + (Math.random() - 0.5) * noise * 5
                ]);
                labels.push(Math.floor(i / (n / 3)));
            }
            return { data, labels };
        }
        
        // PCA Implementation
        function pca(data) {
            const n = data.length;
            const d = data[0].length;
            
            // Center data
            const means = new Array(d).fill(0);
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < d; j++) {
                    means[j] += data[i][j];
                }
            }
            means.forEach((_, i) => means[i] /= n);
            
            const centered = data.map(row => row.map((val, i) => val - means[i]));
            
            // Simple power iteration for first 2 components
            let v1 = [1, 0, 0];
            for (let iter = 0; iter < 20; iter++) {
                const newV = [0, 0, 0];
                for (let i = 0; i < n; i++) {
                    const dot = centered[i][0] * v1[0] + centered[i][1] * v1[1] + centered[i][2] * v1[2];
                    newV[0] += centered[i][0] * dot;
                    newV[1] += centered[i][1] * dot;
                    newV[2] += centered[i][2] * dot;
                }
                const norm = Math.sqrt(newV[0]**2 + newV[1]**2 + newV[2]**2);
                v1 = [newV[0]/norm, newV[1]/norm, newV[2]/norm];
            }
            
            // Project to 2D
            const result = centered.map(row => {
                const x = row[0] * v1[0] + row[1] * v1[1] + row[2] * v1[2];
                const y = row[0] * v1[1] - row[1] * v1[0]; // Perpendicular component
                return [x, y];
            });
            
            return result;
        }
        
        // Simplified t-SNE
        function tsne(data, labels) {
            const n = data.length;
            let Y = Array(n).fill(0).map(() => [(Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.01]);
            
            // Compute pairwise distances
            const D = Array(n).fill(0).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    let dist = 0;
                    for (let k = 0; k < data[i].length; k++) {
                        dist += (data[i][k] - data[j][k]) ** 2;
                    }
                    D[i][j] = D[j][i] = Math.sqrt(dist);
                }
            }
            
            // Compute P (high-dim similarities)
            const P = Array(n).fill(0).map(() => Array(n).fill(0));
            const sigma = 1.0;
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        P[i][j] = Math.exp(-D[i][j] ** 2 / (2 * sigma ** 2));
                        sum += P[i][j];
                    }
                }
                for (let j = 0; j < n; j++) {
                    P[i][j] /= sum;
                }
            }
            
            // Gradient descent
            const lr = 10;
            for (let iter = 0; iter < 500; iter++) {
                const grad = Array(n).fill(0).map(() => [0, 0]);
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            const dx = Y[i][0] - Y[j][0];
                            const dy = Y[i][1] - Y[j][1];
                            const dist = Math.sqrt(dx * dx + dy * dy) + 1e-10;
                            const q = 1 / (1 + dist * dist);
                            const factor = 4 * (P[i][j] - q) * q;
                            grad[i][0] += factor * dx;
                            grad[i][1] += factor * dy;
                        }
                    }
                }
                
                for (let i = 0; i < n; i++) {
                    Y[i][0] -= lr * grad[i][0];
                    Y[i][1] -= lr * grad[i][1];
                }
            }
            
            return Y;
        }
        
        // Simplified UMAP
        function umap(data, labels) {
            const n = data.length;
            let Y = Array(n).fill(0).map(() => [(Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10]);
            
            // Compute distances
            const D = Array(n).fill(0).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    let dist = 0;
                    for (let k = 0; k < data[i].length; k++) {
                        dist += (data[i][k] - data[j][k]) ** 2;
                    }
                    D[i][j] = D[j][i] = Math.sqrt(dist);
                }
            }
            
            // Find k-nearest neighbors
            const k = 15;
            const neighbors = Array(n).fill(0).map(() => []);
            for (let i = 0; i < n; i++) {
                const dists = D[i].map((d, j) => ({ d, j })).filter(x => x.j !== i);
                dists.sort((a, b) => a.d - b.d);
                neighbors[i] = dists.slice(0, k).map(x => x.j);
            }
            
            // Optimize layout
            const lr = 1.0;
            const a = 1.58, b = 0.9;
            
            for (let iter = 0; iter < 300; iter++) {
                for (let i = 0; i < n; i++) {
                    // Attractive forces (neighbors)
                    for (let j of neighbors[i]) {
                        const dx = Y[i][0] - Y[j][0];
                        const dy = Y[i][1] - Y[j][1];
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1e-10;
                        const attr = -2 * a * b * Math.pow(dist, 2 * b - 2) / (1 + a * Math.pow(dist, 2 * b));
                        Y[i][0] -= lr * attr * dx / dist;
                        Y[i][1] -= lr * attr * dy / dist;
                    }
                    
                    // Repulsive forces (sample of non-neighbors)
                    for (let j = 0; j < 5; j++) {
                        const idx = Math.floor(Math.random() * n);
                        if (idx !== i && !neighbors[i].includes(idx)) {
                            const dx = Y[i][0] - Y[idx][0];
                            const dy = Y[i][1] - Y[idx][1];
                            const dist = Math.sqrt(dx * dx + dy * dy) + 1e-10;
                            const rep = 2 * b / ((1e-4 + dist * dist) * (1 + a * Math.pow(dist, 2 * b)));
                            Y[i][0] += lr * rep * dx / dist;
                            Y[i][1] += lr * rep * dy / dist;
                        }
                    }
                }
            }
            
            return Y;
        }
        
        function createChart(ctx, data, labels, title) {
            if (charts[title]) {
                charts[title].destroy();
            }
            
            const datasets = [];
            const uniqueLabels = [...new Set(labels)];
            
            uniqueLabels.forEach(label => {
                const points = data.filter((_, i) => labels[i] === label);
                datasets.push({
                    label: `Cluster ${label}`,
                    data: points.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: colors[label % colors.length],
                    pointRadius: 4,
                    pointHoverRadius: 6
                });
            });
            
            charts[title] = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        tooltip: { enabled: true }
                    },
                    scales: {
                        x: { display: true, grid: { color: '#e2e8f0' } },
                        y: { display: true, grid: { color: '#e2e8f0' } }
                    }
                }
            });
        }
        
        function generateData() {
            const dataset = document.getElementById('dataset').value;
            const samples = parseInt(document.getElementById('samples').value);
            const noise = parseFloat(document.getElementById('noise').value);
            
            let result;
            switch(dataset) {
                case 'blobs': result = generateBlobs(samples, noise); break;
                case 'circles': result = generateCircles(samples, noise); break;
                case 'moons': result = generateMoons(samples, noise); break;
                case 'swiss': result = generateSwissRoll(samples, noise); break;
            }
            
            const { data, labels } = result;
            
            // Apply dimensionality reduction
            const pcaResult = pca(data);
            const tsneResult = tsne(data, labels);
            const umapResult = umap(data, labels);
            
            // Create charts
            createChart(document.getElementById('pcaChart').getContext('2d'), pcaResult, labels, 'PCA');
            createChart(document.getElementById('tsneChart').getContext('2d'), tsneResult, labels, 't-SNE');
            createChart(document.getElementById('umapChart').getContext('2d'), umapResult, labels, 'UMAP');
        }
        
        // Generate initial visualization
        generateData();
    </script>
</body>
</html>